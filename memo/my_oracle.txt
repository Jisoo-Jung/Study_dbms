DB(Database)
	데이터가 모여있는 기지
	추상적인 용어

DBMS(Database Management System)
	DB를 관리할 수 있는 구체적인 시스템
	오라클, 마리아DB, MySQL, MS-SQL, NO-SQL 등

오라클 DBMS 버전
	i: internet
	g: grid
	c: cloud

오라클 DBMS 설치 - 11G //경험상 오라클은 홀수 버전이 좋다.(강사) //오라클 삭제해야할 시 강사님께 얘기하기. 혼자 하지말기
	https://drive.google.com/file/d/1rM1Z7-mA6vjySBgwWLr3ZI883xiL27HN/view?usp=sharing

scott 계정 활성화
	> sqlplus system/1234

	SQL > @[scott.sql 파일의 전체 경로]	: 직접 작성하거나 파일을 드래그 앤 드랍하기
	SQL > show user
		USER is "SCOTT"
	SQL > conn system/1234;
	SQL > alter user scott identified by 1234;
	SQL > conn scott/1234;
	SQL > show user
		USER is "SCOTT"
========================================================================
DBMS의 소통방식
------------------------------------------------------------------------
					사용자
------------------------------------------------------------------------
		↕	   		 ↕			↕
고객 관리 응용프로그램	 ↕	주문 관리 응용프로그램
		↕	   		 ↕			↕
------------------------------------------------------------------------
					DBMS
------------------------------------------------------------------------

RDBMS(관계형 데이터베이스 시스템)
	테이블끼리 서로 관계를 맺는다. //주의: 테이블이 독립적일 수 있다. 항상 연결되어야 하는 것은 아니니깐.

회원 테이블(TBL_USER)					주문 테이블(TBL_ORDER)
번호		이름		나이		아이디		주문번호	번호		날짜				상품수량
1		한동석	20		hds1234		1		1		2024-07-27		5
2		하민지	17		hmj9999		2		1		2024-07-28		10
3		용호중	15		yhj7777		3		4		2024-07-28		1
4		안수진	45		asj7878		4		3		2024-07-29		520

이러한 구조를 가지는 것을 Table, Relation(오라클), Class라고 부른다.

COLUMN(열, 속성, 필드)
	공통된 값들의 주제, 하나의 집합을 의미한다.

ROW(행, 레코드, 튜플)
	하나의 정보를 의미한다.

PRIMARY KEY(PK)
	고유한 값.
	각 행의 구분점으로 사용된다.
	중복이 없고 NULL값을 허용하지 않는다.
	*NULL: 아직 어떤 값을 넣을 지 모르겠다는 의미로 넣는 값.

FORIEGN KEY(FK)
	다른 테이블의 PK를 의미한다.
	보통 테이블끼리 관계를 맺을 때 사용한다.
	중복이 가능하고 NULL도 허용한다.

UNIQUE KEY(UK)
	NULL을 허용하지만 중복은 허용하지 않는다.
-----------------------------------------------------------------------------------------------------------------------------
컴파일 언어와 인터프리터(스크립트) 언어

- 컴파일러
	파일 단위로 해석한다.
	처음부터 끝까지 다시 읽어와야 하는 작업에 적합하다.
	
- 인터프리터
	한 줄 단위로 해석한다.
	빈번한 수정 또는 부분 실행 작업에 적합하다.

SQL문(쿼리문) - DDL, DML, DCL, TCL
	스크립트 언어(인터프리트 언어)이다.
	DBMS와 소통하는 언어이다.

DDL(Data Definition Language): 데이터 정의어
	테이블 조작 및 제어 관련 쿼리문

	1. CREATE: 테이블 생성
		CREATE TABLE [테이블명] (
			[컬럼명] [자료형(용량)] [제약조건],
			[컬럼명] [자료형(용량)] [제약조건],
			...,
			추가 제약 조건
		);

	2. DROP: 테이블 삭제
			DROP TABLE [테이블명]		//한번 삭제되면 복구 안됨. //평생 쓸 일 없을것임.
	
	3. ALTER: 테이블 수정 
	//테이블 수정하는 명령문은 굉장히 많은데, 검색해서 쓰라 //자주 쓰는 것을 주로 쓴다.
		


	4. TRUNCATE: 테이블 내용 전체 삭제	
	//이 또한 쓸 일이 없을것임. //이걸하면 다른 사람들이 삭제했는지 알 수가 없다.
			TRUNCATE TABLE [테이블명]

자료형[TYPE]: 용량은 항상 넉넉하게 주도록 한다.

		숫자
		문자열
		날짜


데이터들을 정리된 표로 확인할 수 있게 해주는 것이 스키마.


==============================================================
무결성
		데이터의 정확성, 일관성, 유효성이 유지되는 것.

		정확성: 데이터는 애매하지 않아야 된다.
		일관성: 각 사용자가 일관된 데이터를 볼 수 있도록 해야 한다.
		유효성: 데이터가 실제 존재하는 데이터여야 한다.	

		1. 개체 무결성
				모든 테이블이 반드시 PK로 설정된 컬럼을 가져야 한다.

		2. 참조 무결성
				두 테이블의 데이터가 항상 일관된 값을 가지도록 유지하는 것

		3. 도메인 무결성
				컬럼의 타입, NULL 값의 허용 등에 대한 사항을 정의하고
				올바른 데이터가 입력되었는지를 확인하는 것
--------------------------------------------------------------
모델링(기획)
		추상적인 주제를 RDB에 맞게 설계하는 것

1. 요구사항 분석
		회원, 주문, 상품: 

2. 개념적 설계(개념 모델링)
		회원		주문			상품
		----------------------
		아이디	주문번호		상품번호
		----------------------
		비밀번호	주문날짜		상품명
		이름		아이디		가격
		주소		상품번호		재고량
		이메일
		생일

3. 논리적 설계
   회원		주문			상품
   -----------------------------------------------
   아이디P   	주문번호P   	상품번호P
   -----------------------------------------------
   비밀번호   	주문 날짜      	상품명
   이름   		아이디F      	가격 D0
   주소   		상품번호F      	재고량 D0
   이메일U
   생일

4. 물리적 설계
  		 USER
   -----------------------
   userId : VARCHAR2(1000)
   -----------------------
   userPw : VARCHAR2(1000)
   userAddress : VARCHAR2(2000)
   userEmail : VARCHAR2(2000) : UNIQUE
   userBirth : DATE

5. 구현


오늘 목표: 테이블 간의 관계를 확실히 알 수 있다.
꽃 테이블과 화분 테이블, 꽃과 화분이 이런 조건이 없


꽃 하나에 화분 여러개. 1:다, 다 쪽에 FK가 있더라. 이상할 때 따져보기(일할 때는 바쁘니) FK를 넣어야 하는 이유를 자세히 말씀해주심. ~9시20분


컨트롤 쉬프트 - 이동

FK_FLOWER_POT  -- 'FLOWER_POT' 우리만의 명령어?? 약속이라고 하심.

내가 잘못 이해한 것

	꽃			화분
	상품번호		제품번호								
	이름			색상
	색상			모양
	가격			재고량
	화분 제품번호
	재고량


	꽃			화분
	--------------------------------------
	상품번호PK		제품번호PK	
	--------------------------------------							
	이름NN		색상NN
	색상NN		모양NN
	가격D0		재고D0
				재고D0
				화분제품번호FK,NN


 POT
 -----------------------------------
 ID:NUMBER:PRIMARY KEY	
 ----------------------------------
 POT_COLOR:VARCHAR2(1000):NOT NULL
 POT_SHAPE:VARCHAR2(1000):NOT NULL
 POT_STOCK:NUMBER:DEFAULT 0

 
 FLOWER
 -----------------------------------
 ID:NUMBER:PRIMARY KEY	
 ----------------------------------
 FLOWER_NAME:VARCHAR2(1000):NOT NULL	
 FLOWER_COLOR:VARCHAR2(1000):NOT NULL	
 FLOWER_PRICE:NUMBER:DEFAULT 0
 FLOWER_STOCK:NUMBER:DEFAULT 0
 POT_ID:NUMBER:FOREIGN KEY:NOT NULL 






매일매일 배운 내용을 깃허브에 정리해놓아야 한다. 매일매일 한번씩 PUSH하는 것이 정신건강이 좋다. 시간이 되면 
바로 GIT을 꺼내서 오늘 자료 PUSH해놓고 공부해놓으면 된다. - 뭔말???


파일 입출력 하려면 경로가 필요.(이미지//파일) DB는 경로만 저장하면 됨.
프로필-경로 NOT NULL
프로필-사이즈 디폴트0
STATUS NUMBER 디폴트0 (0 또는 1)



ID NUMBER CONSTRAINT PK_MEMBER PRIMARY KEY,

MEMBER_ID VARCHAR2(255) CONSTRAINT UK_MEMBER UNIQUE,

ORDER_COUNT NUMBER DEFAULT 1,
   CONSTRAINT FK_ORDER_MEMBER FOREIGN KEY(MEMBER_ID)
   REFERENCES TBL_MEMBER(ID)

CREATE TABLE TBL_

-----------------------------------------


==============================================================정규화
   삽입/수정/삭제 이상현상을 제거하기 위한 작업.
   데이터 중복을 최소화하는 데에 목적이 있다.
   5차 정규화까지 있으나 3차 정규화까지만 진행한다.

1차 정규화
   같은 내용의 컬럼이 연속적으로 나타날 경우.

   상품 테이블
   상품명1      상품명2      상품명3
   와이셔츠1      와이셔츠2      와이셔츠3

   회원 테이블
   취미
   축구, 럭비, 골프

   * 위 테이블은 조회 및 추가가 힘들다.

   1차 정규화 진행

   상품명
   와이셔츠1
   와이셔츠2
   와이셔츠3

   상품명 테이블
   번호   상품명      상품번호(FK)
   1   와이셔츠1      1
   2   와이셔츠2      1
   3   와이셔츠3      1

2차 정규화
   조합키(복합키)로 구성되었을 경우 조합키의 일부분에만 종속되는 속성이 있을 경우(부분 종속).

   꽃
   이름   색상   꽃말   과
   해바라기   노란색   행운   국화
   장미   빨간색   사랑   장미
   
   * 이름에 대한 부분종속이 발생한다.


   2차 정규화 진행

   꽃
   이름   색상   꽃말
   해바라기   노란색   행운
   장미   빨간색   사랑

   과
   이름   과
   해바라기   국화
   장미   장미

3차 정규화   
   PK가 아닌 컬럼이 다른 컬럼을 결정하는 경우
   이행 함수 종속 제거

   회원번호      이름   시   구   동   우편번호
   1      한동석   경기도   남양주   화도   12345
   2      홍길동   서울시   관악구   봉천   78945

   * 우편번호로 시, 구, 동을 알 수 있다.
   * 중복된 데이터가 생길 가능성이 있다.

   3차 정규화 진행

   회원 테이블
   회원번호      이름   우편번호
   1      한동석   12345
   2      홍길동   78945

   우편번호 테이블
   우편변호      시   구   동
   12345      경기도   남양주   화도
   78945      서울시   관악구   봉천   

데이터베이스에서 정규화가 필요한 이유
   데이터베이스를 잘못 설계하면 불필요한 데이터 중복으로 인해 공간이 낭비된다.
   이런 현상을 이상(Anomaly)현상이라고 한다.


   회원번호와 프로젝트코드 두 컬럼의 조합키로 설정되어 있는 테이블이고
   한 사람은 하나의 부서만 가질 수 있다.

   회원번호      이름   부서   프로젝트코드   급여   부서별 명수
   22080101      한동석   개발팀   ABC0001      3000   4
   22080101      한동석   개발팀   DEF1112      2000   4
   22080101      한동석   개발팀   CBA9474      4000   4
   22080104      홍길동   기획팀   EFG0881      5000   2
   22081106      이순신   디자인팀   GHI9991      6000   3


이상현상의 종류
1. 삽입 이상
      새 데이터를 삽입하기 위해 불필요한 데이터도 삽입해야하는 문제
   
      담당 프로젝트가 정해지지 않은 사원이 있다면,
      프로젝트 코드에 NULL을 작성할 수 없으므로 이 사원은 테이블에 추가될 수 없다.
      따라서 '미정'이라는 프로젝트 코드를 따로 만들어서 삽입해야 한다.

2. 갱신 이상
      중복 행 중에서 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제

      한 명의 사원은 반드시 하나의 부서에만 속할 수 있다.
      만약 "한동석"이 보안팀으로 부서를 옮길 시 3개 모두 갱신해주지 않는다면
      개발팀인지 보안팀인지 알 수 없다.

3. 삭제 이상
      행을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 문제
   
      "이순신"이 담당한 프로젝트를 박살내서 드랍된다면 "이순신" 행을 모두 삭제하게 된다.
      따라서 프로젝트에서 드랍되면 정보를 모두 드랍하게 된다.


정규화 진행

   회원번호      프로젝트코드   급여
   22080101      ABC0001      3000
   22080101      DEF1112      2000
   22080101      CBA9474      4000
   22080104      EFG0881      5000
   22081106      GHI9991      6000

   회원번호      이름      부서
   22080101      한동석      개발팀
   22080104      홍길동      기획팀
   22081106      이순신      디자인팀

   부서   부서별 명수
   개발팀   4
   기획팀   2
   디자인팀   3
================================================================================
DML(Data Manipulation Language): 데이터 조작어
   1. SELECT: 조회(검색)
      SELECT [컬럼명1, 컬럼명2, ...]
      FROM [테이블명]
      WHERE [조건식]

   2. INSERT: 추가
      1) 컬럼명을 생략할 수 있으며, 이 경우 DEFAULT 제약조건이 발생된다.
         INSERT INTO [테이블명]
         ([컬럼명1, 컬럼명2, ...])
         VALUES([값1, 값2, ...]);

      2) 모든 값을 전부 작성해야 하며, 컬럼명은 직접 작성하지 않는다.
         INSERT INTO [테이블명]
         VALUES([값1, 값2, ...]);

   3. UPDATE: 수정
      UPDATE [테이블명]
      SET [기존 컬럼명1] = [새로운 값1], [기존 컬럼명2] = [새로운 값2], ...
      WHERE [조건식]

   4. DELETE: 삭제
      DELETE FROM [테이블명]
      WHERE [조건식]

조건식
   >, <:      초과, 미만
   >=, <=:      이상, 이하
   =:      같다
   <>, != , ^=:   같지 않다.
   AND:      둘 다 참이면 참
   OR:      둘 중 하나라도 참이면 참
=================================================================================

CREATE SEQUENCE SEQ_MEMBER;


/*각 테이블에 3개 이상씩 정보를 추가하고, 조회한다.*/
SELECT * FROM TBL_MEMBER;

INSERT INTO TBL_MEMBER
VALUES(SEQ_MEMBER.NEXTVAL, 'hds1234', '1234', '한동석', '경기도 남양주', 'hds1234@gamilc.om' , TO_DATE('2000-12-04', 'YYYY-MM-DD'));
INSERT INTO TBL_MEMBER
VALUES(SEQ_MEMBER.NEXTVAL, 'hgd1234', '1234', '홍길동', '서울시 강남구', 'hgd1234@gamilc.om' , TO_DATE('2020-11-24', 'YYYY-MM-DD'));
INSERT INTO TBL_MEMBER
VALUES(SEQ_MEMBER.NEXTVAL, 'lss1234', '1234', '이순신', '대구광역시 달서구', 'lss1234@gamilc.om' , TO_DATE('2010-01-04', 'YYYY-MM-DD'));

SELECT ID, MEMBER_ID, MEMBER_PASSWORD, MEMBER_NAME, MEMBER_ADDRESS, MEMBER_EMAIL, MEMBER_BIRTH 
FROM TBL_MEMBER;

CREATE SEQUENCE SEQ_PRODUCT;

SELECT * FROM TBL_PRODUCT;

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '안경', 129000, 32);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '키보드', 344000, 2);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 174000, 102);

SELECT ID, PRODUCT_NAME, PRODUCT_PRICE, PRODUCT_STOCK FROM TBL_PRODUCT;

CREATE SEQUENCE SEQ_ORDER;

SELECT * FROM TBL_ORDER;

INSERT INTO TBL_ORDER (ID, MEMBER_ID, PRODUCT_ID)
VALUES(SEQ_ORDER.NEXTVAL, 2, 3);
INSERT INTO TBL_ORDER (ID, MEMBER_ID, PRODUCT_ID)
VALUES(SEQ_ORDER.NEXTVAL, 1, 3);
INSERT INTO TBL_ORDER (ID, MEMBER_ID, PRODUCT_ID)
VALUES(SEQ_ORDER.NEXTVAL, 3, 1);

SELECT ID, ORDER_DATE, MEMBER_ID, PRODUCT_ID FROM TBL_ORDER;

/*수정 2회*/
UPDATE TBL_ORDER
SET PRODUCT_ID = 1
WHERE ID = 1;

UPDATE TBL_PRODUCT
SET PRODUCT_PRICE = PRODUCT_PRICE * 1.1

/*삭제 2회*/
DELETE FROM TBL_ORDER
WHERE ID = 3;

DELETE FROM TBL_PRODUCT
WHERE ID = 2;





정규화 - 조회는 편하지만 관리하기 힘드니, 정규화를 하자.

이 중에서는 회사에서 SELECT만 할 것입니다. 신입들은 보통 SELECT하여 조회할 것임.
나머지는 신입들에게 주지 않을거임. //그래도 열심히 배우자.//연습하는 것은 반복만 하면 됨.


성능차이 - 먼저 할 수 있는 것은 WHERE 절을 써라.
합쳐져서 나야 해야 할 것은 ON절에서 AND해서 WHERE절을 쓰는 것. ->나중에 메모장에 정리 (반대로 말한 것 같다고 헷갈리다고 하심.)

먼저 제거할 것 제거하고, 등등.(나중에 정리해주신다고 함. 헷갈리다고 하시니 찾아보기)

WHERE절이 아마 JOIN보다 늦게 될 것이에요. 그래서 AND로 연결해야...하는 것 같다고 또 하심. 



























































